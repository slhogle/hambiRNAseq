---
title: "Modeling effects of _Pseudomonas_ evolution on predator density"
output: 
  html_notebook
---

<!-- output:  -->
<!--   github_document: -->
<!--     toc: yes -->
<!--     toc_depth: 2 -->
<!--     fig_width: 7 -->
<!--     fig_height: 5 -->
<!--     dev: png -->
<!--     keep_html: yes -->
<!--     html_preview: yes -->
    
```{r echo=TRUE, message=FALSE, warning=FALSE}
library(here)
library(tidyverse)
library(fitdistrplus)
```

# READ AND FORMAT
We started each bacterial species at 10<sup>6<sup/> cells per mL except for 
_Pseudomonas_ which we inoculated at 10<sup>7<sup/> cells per mL.

[useful post](https://stats.stackexchange.com/a/127559) for making dummy interaction variables
```{r message=FALSE, warning=FALSE}
set.seed(123)
metadata <- read_tsv(here("data", "metadata.tsv"), col_types="cfffffff") %>%
  mutate(pseudomonas_hist=factor(pseudomonas_hist, levels=c("ancestral", "coevolved")),
         tetra_hist=factor(tetra_hist, levels=c("no_tetra", "coevolved")))

# we started ciliates at ~5000 cells per mL.
cil <- read_tsv(here("data", "cilliate_counts.tsv"), col_types="cddddddddddd") %>%
  mutate(`1`= rnorm(18, mean=5000, sd=1000)) %>%
  gather(day, value, -sample) %>%
  mutate(day=as.numeric(day))
```

```{r}
set.seed(3427)
#setup the categorical vars
cil1 <- left_join(cil, metadata, by="sample") %>% 
  filter(pseudomonas_hist %in% c("ancestral", "coevolved")) %>%
  filter(tetra_hist %in% c("coevolved", "no_tetra")) %>%
   mutate(pred=ifelse(str_detect(tetra_hist, "coevolved"), "predation", "none"),
         evo=ifelse(str_detect(pseudomonas_hist, "coevolved"), "evolution", "none"),
         pred_evo=ifelse(str_detect(tetra_hist, "coevolved") & 
                           str_detect(pseudomonas_hist, "coevolved"), "interaction", "none")) %>%
  group_by(pred, evo, replicate) %>%
  mutate(id=dplyr::cur_group_id()) %>%
  ungroup()

# scale response var
# there is a detection limit for ciliates at about 1000 per mL. Any lower than that and noise takes over so you get lots of zeros and weird low values. Here we are just randomly sampling from normal distribution for all counts below 1000
cil2 <- cil1 %>%
  #group_by(id) %>%
  rowwise() %>%
  mutate(value2=ifelse(value < 1000, rnorm(1, mean=1000, sd=500), value)) %>%
  ungroup() %>%
  mutate(value2=ifelse(value2 < 0, 300, value2)) %>%
  mutate(vallog=log10(value2),    # for Gaussian
         valsqrt=(value2)^(1/2), 
         count=ceiling(value2),     # for beta binomial
         recoveryonset=day-43) %>%
  mutate(countred=ceiling(count/100),
         vallogscale=scale(vallog)) %>%
  ungroup()


# finalize data
cil3 <- cil2 %>%
  dplyr::select(pred, evo, pred_evo, recoveryonset, day, id, count, countred, vallog, vallogscale, valsqrt) %>%
  arrange(id, day) %>%
  mutate(pred=as.factor(pred),
         evo=as.factor(evo),
         pred_evo=as.factor(pred_evo),
         recoveryonset=as.numeric(recoveryonset),
         day=as.numeric(day), 
         id=as.factor(id),
         count=as.numeric(count),
         vallogscale=as.numeric(vallogscale)) %>%
  as.data.frame()

saveRDS(cil3, here::here("bin", "cluster", "cil3.rds"))
```


```{r}
cil3 %>%
  pivot_longer(cols=c(vallogscale, vallog, valsqrt, countred, count)) %>%
  ggplot() + 
  geom_line(aes(x=day, y=value, group=id, color=evo)) +
  facet_grid(name ~ ., scales="free_y") + 
  #scale_y_continuous(trans="sqrt") + 
  theme_bw()
```

# BEST PROBABILITY DISTRIBUTIONS

[This is a good, short explanation](https://stats.stackexchange.com/a/303592) 
for choosing the probability distribution. 

The two most relevant options in this case are NB and gaussian:
1. Gaussian: (a.k.a. normal distribution).
 - Continuous
 - Unbounded
2. Negative binomial
 - Continuous
 - Bounded, outcome is non-negative

```{r message=FALSE, warning=FALSE}
fit.n <- fitdist(cil3$vallog, "norm")
fit.ln <- fitdist(cil3$count, "lnorm")
fit.nb <- fitdist(cil3$count, "nbinom")
```

### Histograms and theoretical densities
```{r}
denscomp(fit.n, legendtext="scaled-Gaussian", probability = T)
```

```{r}
denscomp(fit.ln, legendtext="Log-gaussian", probability = T)
```

### Q-Q plots
```{r}
qqcomp(fit.n, legendtext="Scaled-gaussian")
```

```{r}
qqcomp(fit.ln, legendtext="Log-gaussian", xlogscale = T, ylogscale = T)
```

### Empirical and theoretical CDFs
```{r}
cdfcomp(fit.n, legendtext="Scaled-gaussian")
```

```{r}
cdfcomp(list(fit.ln,fit.nb),legendtext=c("Log-gaussian","Neg Binom"))
```

### Theoretical/empirical probs
```{r}
ppcomp(fit.n, legendtext="Scaled-gaussian")
```

```{r}
ppcomp(fit.ln, legendtext="Log-gaussian")
```

Will use gaussian with a log10 transform because it makes computation with Gaussian process regression more computationally straightforward and hence faster.

# MODELING
```{r}
library(lgpr)
```

```{r}
lgpinput <- cil3 %>% 
  dplyr::select(-count, -countred) %>%
  dplyr::rename(y=vallogscale)

my_prior.g <- list(
              wrp = log_normal(-0.1, 0.2)
              )

fit.g <- lgp(y ~ gp(day) + zs(id)*gp(day) + categ(pred)*gp(day) + categ(evo)*gp(day) + 
                categ(pred_evo)*gp(day) + gp_vm(recoveryonset),
              lgpinput, 
              likelihood = "gaussian",
              prior = my_prior.g,
              verbose = TRUE,
              refresh = 500,
              chains = 4,
              cores = 4,
              control = list(adapt_delta = 0.95),
              iter = 200)
```

## DEFINE PRIORS
 
### WARP STEEPNESS
Warp needs to be pretty steep since the change happens within 5 days or so. 

Setting mu to -0.1 and sigmap to 0.2 seems to achieve this effect
```{r}
num_draws <- 300
mu_wrp <- -0.1
sigma_wrp <- 0.2

r <- range(cil3$recoveryonset, na.rm = TRUE)

# Prior draws
wrp_draws <- stats::rlnorm(num_draws, mu_wrp, sigma_wrp)

# Plot corresponding input warping functions
# - this function is not exported from lgpr so we need to use triple colons :::
# - alpha here is line opacity, not a GP parameter
lgpr:::plot_inputwarp(wrp_draws, seq(r[1], r[2], by = 1), alpha = 0.1)
```

## GAUSSIAN

### ZERO-SUM KERNELS FOR EVOLUTION, PREDATION, PRED_EVO

Read in the saved Stan object if coming back to this later
```{r}
fit.g1 <- readRDS(here::here("output", "fit-cil-zs-gs.rds"))
```

#### CHECK POSTERIOR
```{r}
plot_draws(fit.g1, type = 'dens')
```

#### COMPONENT RELEVANCES
```{r}
rel <- lgpr:::relevances.default.all(fit.g1) %>% tibble() %>%
  pivot_longer(everything()) %>%
  mutate(measure="ciliate")

thresh <- select(fit.g1, threshold = 0.95) %>% rownames_to_column(var="name") %>% tibble()

relf <- left_join(rel, thresh)

saveRDS(relf, here::here("output", "relevance_cil.rds"))

ggplot(relf, aes(x=name, y=value, fill=Component)) +
    geom_violin(scale="width")
```

```{r}
data.frame(relevances(fit.g1, reduce = mean)) %>% 
  rownames_to_column(var="variable") %>% tibble()
```

```{r}
select(fit.g1, threshold = 0.95)
```

```{r}
threshold_density <- function(x) {stats::dbeta(x, 20, 2)}
s <- select.integrate(fit.g1, p = threshold_density)
print(s$expected)
```

```{r}
t <- seq(1, 55, by = 1)
x_pred <- new_x(lgpinput, t, x="day", x_ns = "recoveryonset")
p <- pred(fit.g1, x_pred, reduce = mean)
plot_pred(fit.g1, x = x_pred, pred = p, t_name="day", group_by=c("id"))
```

```{r}
plot_f(fit.g1, x = x_pred, pred = p, t_name="day",  color_by="evo")
```

```{r}
plot_components(fit.g1,
                x = x_pred, 
                t_name = "day",
                group_by="id", 
                pred = p,
                color_by = c(NA, NA, "evo", NA, "evo"),
                ylim = c(-3,3))
```
# DATA FOR PLOTTING

## SUM FUNCTION PLUS DATA ON ORIGINAL DATA SCALE
```{r}
input <- lgpr:::plot_pred.create_input(fit.g1, p, x_pred, draws, reduce, "id", "day")

data <- lgpr:::create_plot_df(fit.g1, x="day") %>%
  mutate(y=10^y) %>% dplyr::rename(obs=y)

rib <- lgpr:::plot_pred.create.df_ribbon(fit.g1, p, lgpr:::dollar(input, "df_base"), 2) %>%
  mutate(upper=10^upper,
         lower=10^lower)

lines <- lgpr:::plot_pred.create.df_line(fit.g1, p, lgpr:::dollar(input, "df_base")) %>%
  mutate(y=10^y)

cilfinal <- left_join(lines, rib) %>%
  left_join(., data) %>%
  mutate(measure="bacterial") %>%
  left_join(., distinct(dplyr::select(lgpinput, pred, evo, pred_evo, id)))

saveRDS(cilfinal, here::here("output", "data_cil.rds"))

ggplot(cilfinal, aes(x=day, group=id)) + 
  geom_ribbon(aes(ymax=upper, ymin=lower, fill=evo), alpha=0.1) +
  geom_line(aes(y=y, color=evo)) +
  geom_point(aes(y=obs, color=evo)) +
  scale_y_log10() +
  #facet_wrap(~id) +
  theme_bw()
```

## INDIVIDUAL COMPONENTS
```{r}
# 1. time is shared
vardata1 <- left_join(lgpr:::plot_f.create.df_ribbon(fit.g1, p, lgpr:::dollar(input, "df_base"), comp_idx=1, 2),
                 lgpr:::plot_f.create.df_line(fit.g1, p, lgpr:::dollar(input, "df_base"), comp_idx=1)) %>%
  mutate(variable="day") %>%
  dplyr::select(-id) %>% dplyr::distinct()

saveRDS(vardata1, here::here("output", "vars_cil.rds"))

ggplot(vardata1, aes(x=day, y=y, ymax=upper, ymin=lower)) + 
  geom_ribbon(alpha=0.25) +
  geom_line() +
  theme_bw()
```
